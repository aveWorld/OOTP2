Будь-який розробник JavaScript або бачив прототип ключового слова, збентежений прототипним успадкуванням, або реалізував прототипи у своєму коді. Шаблон дизайну прототипу спирається на прототипне успадкування JavaScript. Прототип моделі використовується в основному для створення об'єктів в ситуаціях з інтенсивним виконанням.
Створювані об'єкти є клонами (неглибокими клонами) вихідного об'єкта, які передаються навколо. Одним із варіантів використання прототипу шаблону є виконання великої операції бази даних для створення об'єкта, що використовується для інших частин програми. Якщо інший процес потребує використання цього об'єкта, замість того, щоб виконувати цю істотну операцію бази даних, було б вигідно клонувати раніше створений об'єкт.
![image](https://user-images.githubusercontent.com/46648541/227893457-d0ae0da2-e3e7-4bf0-82d8-dd2b80f93db0.png)


Цей UML описує, як інтерфейс прототипу використовується для клонування конкретних реалізацій.
Щоб клонувати об'єкт, повинен існувати конструктор, щоб створити перший об'єкт. Далі за допомогою ключового слова прототип змінних і методів прив'язують до структури об'єкта. Давайте розглянемо базовий приклад:

var TeslaModelS = function() {
    this.numWheels    = 4;
    this.manufacturer = 'Tesla';
    this.make         = 'Model S';
}

TeslaModelS.prototype.go = function() {
    // Rotate wheels
}

TeslaModelS.prototype.stop = function() {
    // Apply brake pads
}

Конструктор дозволяє створити єдиний об'єкт TeslaModelS. При створенні нового об'єкта TeslaModelS він збереже стани, ініціалізовані в конструкторі. Крім того, підтримувати функцію йти і зупинятися легко, оскільки ми задекларували їх прототипом. Синонімічний спосіб розширення функцій на прототипі, як описано нижче:

Подібно до шаблону модуля, шаблон Prototype також має показову варіацію. Шаблон розкривного прототипу забезпечує інкапсуляцію з публічними та приватними членами, оскільки він повертає об'єкт буквальним.

Оскільки ми повертаємо об'єкт, то будемо префіксувати об'єкт-прототип функцією. Розширюючи наш приклад вище, ми можемо вибрати, що ми хочемо виставити в поточному прототипі, щоб зберегти їх рівні доступу:
var TeslaModelS = function() {
    this.numWheels    = 4;
    this.manufacturer = 'Tesla';
    this.make         = 'Model S';
}

TeslaModelS.prototype = function() {

    var go = function() {
    // Rotate wheels
    };

    var stop = function() {
    // Apply brake pads
    };

    return {
    pressBrakePedal: stop,
    pressGasPedal: go
    }

}();
Зверніть увагу, як функції зупинки та переходу будуть захищені від об'єкта, що повертається, через те, що вони знаходяться за межами області дії повернутого об'єкта. Оскільки JavaScript спочатку підтримує прототипне успадкування, немає необхідності переписувати основні функції.
